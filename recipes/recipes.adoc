= Recipes Guide

:neo4j-version: 3.5.3
:author: Mark Needham
:twitter: @markhneedham

== Recipes Overview


++++
<div class="col-lg-6">
++++

[subs=attributes]
++++
<img src="{img}/pole_model_visual.jpeg" class="img-responsive">
++++

++++
</div>
++++

++++
<div class="col-lg-6">
++++

This guide will demonstrate how Neo4j can be used to make sense of recipes data.


++++
</div>
++++

== Data Import

[source, cypher]
----
CREATE INDEX ON :Recipe(id);
CREATE INDEX ON :Ingredient(name);
CREATE INDEX ON :Keyword(name);
CREATE INDEX ON :DietType(name);
CREATE INDEX ON :Author(name);
CREATE INDEX ON :Collection(name);

:params jsonFile => "https://raw.githubusercontent.com/mneedham/bbcgoodfood/master/stream_clean.json";

CALL apoc.load.json($jsonFile) YIELD value
WITH value.page.article.id AS id,
       value.page.title AS title,
       value.page.article.description AS description,
       value.page.recipe.cooking_time AS cookingTime,
       value.page.recipe.prep_time AS preparationTime,
       value.page.recipe.skill_level AS skillLevel
MERGE (r:Recipe {id: id})
SET r.cookingTime = cookingTime,
    r.preparationTime = preparationTime,
    r.name = title,
    r.description = description,
    r.skillLevel = skillLevel;

CALL apoc.load.json($jsonFile) YIELD value
WITH value.page.article.id AS id,
       value.page.article.author AS author
MERGE (a:Author {name: author})
WITH a,id
MATCH (r:Recipe {id:id})
MERGE (a)-[:WROTE]->(r);

CALL apoc.load.json($jsonFile) YIELD value
WITH value.page.article.id AS id,
       value.page.recipe.ingredients AS ingredients
MATCH (r:Recipe {id:id})
FOREACH (ingredient IN ingredients |
  MERGE (i:Ingredient {name: ingredient})
  MERGE (r)-[:CONTAINS_INGREDIENT]->(i)
);

CALL apoc.load.json($jsonFile) YIELD value
WITH value.page.article.id AS id,
       value.page.recipe.keywords AS keywords
MATCH (r:Recipe {id:id})
FOREACH (keyword IN keywords |
  MERGE (k:Keyword {name: keyword})
  MERGE (r)-[:KEYWORD]->(k)
);

CALL apoc.load.json($jsonFile) YIELD value
WITH value.page.article.id AS id,
       value.page.recipe.diet_types AS dietTypes
MATCH (r:Recipe {id:id})
FOREACH (dietType IN dietTypes |
  MERGE (d:DietType {name: dietType})
  MERGE (r)-[:DIET_TYPE]->(d)
);

CALL apoc.load.json($jsonFile) YIELD value
WITH value.page.article.id AS id,
       value.page.recipe.collections AS collections
MATCH (r:Recipe {id:id})
FOREACH (collection IN collections |
  MERGE (c:Collection {name: collection})
  MERGE (r)-[:COLLECTION]->(c)
);
----


== Graph Schema

Let's review the metagraph, and see the types of nodes and relationships we're going to be working with.

[source,cypher]
----
CALL db.schema()
----

== Most common ingredients

What are the most popular ingredients and in how many recipes have they been used?

[source,cypher]
----
MATCH (i:Ingredient)<-[rel:CONTAINS_INGREDIENT]-(r:Recipe)
RETURN i.name, count(rel) as recipes
ORDER BY recipes DESC
----

The items at the top of the list aren't all that surprising - olive oil, butter, and garlic!
Further down the list we can see some ingredients that are probably used in cakes: sugar, milk, self-raising flour.

== I want chocolate cake!

This dataset also contains collections, and one of the tastiest looking ones is the collection of chocolate cakes.
The following query returns the recipes in this collection:

[source, cypher]
----
MATCH (:Collection {name: "Chocolate cake"})<-[:COLLECTION]-(recipe)
RETURN recipe.id, recipe.name, recipe.description
----

A hunger inducing list, but let's not be greedy, we'll zoom in on that seriously rich chocolate cake.

== Seriously rich chocolate cake

We'll start with the following query, which returns a graph of the recipe and its ingredients:

[source, cypher]
----
MATCH path = (r:Recipe {id:'97123'})-[:CONTAINS_INGREDIENT]->(i:Ingredient)
RETURN path
----

== Are there any similar cakes to this one?

Ok so we've now baked this cake a few times and while it was delicious, we'd like to try out some other recipes.
What other cake are there similar to this one?

[source, cypher]
----
MATCH (r:Recipe {id:'97123'})-[:CONTAINS_INGREDIENT]->(i:Ingredient)<-[:CONTAINS_INGREDIENT]-(rec:Recipe)
RETURN rec.id, rec.name, collect(i.name) AS commonIngredients
ORDER BY size(commonIngredients) DESC
LIMIT 10
----

The query above:

* finds all the ingredients in the seriously rich chocolate cake
* finds other recipes that also contain these ingredients
* returns the recipes that contain the most common ingredients

== What other recipes has the author published?

Another type of recommendation query would be to find the other recipes published by the author of seriously rich chocolate cake.
The following query does this:

[source, cypher]
----
MATCH (rec:Recipe)<-[:WROTE]-(a:Author)-[:WROTE]->(r:Recipe {id:'97123'})
RETURN rec.id, rec.name, rec.description
----

== What can I make with the ingredients in my kitchen?
=== Show me the chillis

[source, cypher]
----
MATCH (r:Recipe)
WHERE (r)-[:CONTAINS_INGREDIENT]->(:Ingredient {name: "chilli"})
RETURN r.name AS recipe,
       [(r)-[:CONTAINS_INGREDIENT]->(i) | i.name]
       AS ingredients
----

== What can I make with the ingredients in my kitchen?
=== Recipes with multiple ingredients (Part 1)

[source,cypher]
----
MATCH (r:Recipe)
WHERE (r)-[:CONTAINS_INGREDIENT]->(:Ingredient {name: "chilli"})
AND   (r)-[:CONTAINS_INGREDIENT]->(:Ingredient {name: "prawn"})
RETURN r.name AS recipe,
       [(r)-[:CONTAINS_INGREDIENT]->(i) | i.name]
       AS ingredients
LIMIT 20
----

== What can I make with the ingredients in my kitchen?
=== Recipes with multiple ingredients (Part 2)

[source,cypher]
----
:param ingredients =>   ["chilli", "prawn"];
----

[source,cypher]
----
MATCH (r:Recipe)
WHERE all(i in $ingredients WHERE exists(
  (r)-[:CONTAINS_INGREDIENT]->(:Ingredient {name: i})))
RETURN r.name AS recipe,
       [(r)-[:CONTAINS_INGREDIENT]->(i) | i.name]
       AS ingredients
ORDER BY size(ingredients)
LIMIT 20
----

== Mark's allergic to all the things

[source,cypher]
----
:param allergens =>   ["egg", "milk"];
:param ingredients => ["coconut milk", "rice"];
----

[source, cypher]
----
MATCH (r:Recipe)

WHERE all(i in $ingredients WHERE exists(
  (r)-[:CONTAINS_INGREDIENT]->(:Ingredient {name: i})))
AND none(i in $allergens WHERE exists(
  (r)-[:CONTAINS_INGREDIENT]->(:Ingredient {name: i})))

RETURN r.name AS recipe,
       [(r)-[:CONTAINS_INGREDIENT]->(i) | i.name]
       AS ingredients
ORDER BY size(ingredients)
LIMIT 20
----
